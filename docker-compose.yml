version: "3.7"

secrets:
# Obfuscates sensitive information from the docker-compose file.
  cloudflare_dns_api_token:
    file: "./secrets/cloudflare_dns_api_token"

services:
# - Variables under environment: can be defined explicitly or referenced from a .env file.
# - All services store persitent data on /mnt/tank/docker.  Modify volumes accordingly.
# - Assumes /mnt/tank/docker set 0775, root:docker.
# - Idea is for all containers to be reverse-proxied behind Traefik.
#   - So either configure Traefik for LetsEncrypt validation via DNS provider, or
#   - create specific internal DNS entries for each container (e.g., plex.domain.local) pointing
#     to IP of docker host.
#   - Internal wildcard DNS entry via dnsmasq could also be used, but lazy.

  ###
  ### SYSTEM MANAGEMENT CONTAINERS
  ###
  # Traefik for container reverse SSL proxy.
  # All containers with an exposed web front-end are proxied through this
  # container.  They need to be on the traefik_proxy network, with
  # appropriate labels to enable them.
  traefik:
    container_name: traefik
    image: traefik
    restart: always
    domainname: ${DOMAINNAME}
    ports:
      - 80:80
      - 443:443
    networks:
      - traefik_proxy
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock:ro
      - ${DOCKER_LOCATION}/traefik2:/etc/traefik
    secrets:
      - "cloudflare_dns_api_token"
    environment:
      - TZ
      - PUID
      - PGID
      # This variable must end in _FILE for the token to be read from a file.
      - "CLOUDFLARE_DNS_API_TOKEN_FILE=/run/secrets/cloudflare_dns_api_token"
    labels:
      # Let traefik handle this container (we do not expose containers by default)
      - traefik.enable=true
      
      # Traefik dashboard settings.
      # Note that the api@internal service is traefik-specific.
      - traefik.http.routers.traefik.rule=Host(`traefik.${DOMAINNAME}`)
      - traefik.http.routers.traefik.service=api@internal
      - traefik.http.routers.traefik.tls.certresolver=letsencrypt
      - traefik.http.routers.traefik.entrypoints=websecure

      # Password auth (optional) - uses htpasswd user/pass 
      #- "traefik.http.routers.traefik.middlewares=authtraefik"
      #- "traefik.http.middlewares.authtraefik.basicauth.users=user:xxx"

      # Global redirect all incoming http to https
      - traefik.http.routers.http-catchall.rule=hostregexp(`{host:.+}`)
      - traefik.http.routers.http-catchall.entrypoints=web
      - traefik.http.routers.http-catchall.middlewares=redirect-to-https

      # Middleware for https redirect
      - traefik.http.middlewares.redirect-to-https.redirectscheme.scheme=https


  # Watchtower keeps all other containers current
  watchtower:
    container_name: watchtower
    restart: unless-stopped
    #image: v2tec/watchtower # project seems dead?
    image: containrrr/watchtower
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock
    # Checks for new container images every day at 7AM (cron format)
    command: --schedule "0 0 7 * * *" --cleanup
    environment:
      - TZ


  # Web management for containers 
  portainer:
    image: portainer/portainer
    container_name: portainer
    restart: always
    command: -H unix:///var/run/docker.sock
    networks:
      - traefik_proxy
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock
      - ${DOCKER_LOCATION}/portainer/data:/data
      - ${DOCKER_LOCATION}/shared:/shared
    environment:
      - TZ
      - PUID
      - PGID
    labels:
      - traefik.enable=true
      - traefik.http.routers.portainer.rule=Host(`portainer.${DOMAINNAME}`)
      - traefik.http.routers.portainer.entrypoints=websecure
      - traefik.http.routers.portainer.tls=true
      - traefik.http.routers.portainer.tls.certresolver=letsencrypt
      - traefik.http.services.portainer.loadbalancer.server.port=9000
  

  # Duplicati for cloud backups of important data.
  duplicati:
    container_name: duplicati
    image: linuxserver/duplicati
    restart: always
    networks:
      - traefik_proxy
    # First run:  Uncomment the ports definition below, SSH into into docker host with:
    # ssh user@host -L 8200:localhost:8200, log into web UI on http://localhost:8200
    # Modify Hostnames field to allow the duplicati container hostname (duplicati.${DOMAINNAME})
    # Save, stop container, uncomment the lines below, restart.
    #ports:
    #  - 8200:8200
    volumes:
      - ${DOCKER_LOCATION}/duplicati:/config
      - /home:/source
    environment:
      - PUID
      - PGID
      - TZ
    labels:
      - traefik.enable=true
      - traefik.http.routers.duplicati.rule=Host(`duplicati.${DOMAINNAME}`)
      - traefik.http.routers.duplicati.entrypoints=websecure
      - traefik.http.routers.duplicati.tls=true
      - traefik.http.routers.duplicati.tls.certresolver=letsencrypt
      - traefik.http.services.duplicati.loadbalancer.server.port=8200
        
  
  ###
  ### MEDIA SERVER CONTAINERS
  ###
  # Emby for media streaming
  emby:
    container_name: emby
    image: emby/embyserver
    restart: always
    networks:
      - traefik_proxy
    volumes:
      - ${DOCKER_LOCATION}/emby:/config
      - /mnt/tank/media/tv:/mnt/tv
      - /mnt/tank/media/movies:/mnt/movies
    environment:
      - TZ
      - UID=${PUID}
      - GID=${PGID}
    labels:
      - traefik.enable=true
      - traefik.http.routers.emby.rule=Host(`emby.${DOMAINNAME}`)
      - traefik.http.routers.emby.entrypoints=websecure
      - traefik.http.routers.emby.tls=true
      - traefik.http.routers.emby.tls.certresolver=letsencrypt
      - traefik.http.services.emby.loadbalancer.server.port=8096
       

  # Sabnzbd for snatching usenet NZBs
  sabnzbd:
    container_name: sabnzbd
    image: linuxserver/sabnzbd
    restart: always
    networks:
      - traefik_proxy
    volumes:
      - ${DOCKER_LOCATION}/sabnzbd:/config
      - ${DOCKER_LOCATION}/shared/downloads/complete:/downloads/complete
      - ${DOCKER_LOCATION}/shared/downloads/incomplete:/downloads/incomplete
    environment:
      - TZ
      - PUID
      - PGID
    labels:
      - traefik.enable=true
      - traefik.http.routers.sabnzbd.rule=Host(`sabnzbd.${DOMAINNAME}`)
      - traefik.http.routers.sabnzbd.entrypoints=websecure
      - traefik.http.routers.sabnzbd.tls=true
      - traefik.http.routers.sabnzbd.tls.certresolver=letsencrypt
      - traefik.http.services.sabnzbd.loadbalancer.server.port=8080
   

  # Sonarr for TV series management
  sonarr:
    container_name: sonarr
    image: linuxserver/sonarr
    restart: always
    networks:
      - traefik_proxy
    # Monitors the same directory as sabnzbd for completed downloads,
    # moves them to same directory for Plex/Emby TV library.
    volumes:
      - /etc/localtime:/etc/localtime:ro
      - ${DOCKER_LOCATION}/sonarr:/config
      - ${DOCKER_LOCATION}/shared/downloads:/downloads
      - /mnt/tank/media/tv:/tv
    environment:
      - TZ
      - PUID
      - PGID
    labels:
      - traefik.enable=true
      - traefik.http.routers.sonarr.rule=Host(`sonarr.${DOMAINNAME}`)
      - traefik.http.routers.sonarr.entrypoints=websecure
      - traefik.http.routers.sonarr.tls=true
      - traefik.http.routers.sonarr.tls.certresolver=letsencrypt
      - traefik.http.services.sonarr.loadbalancer.server.port=8989
     

  ###
  ### Network Management
  ###
  # UniFi AP management utility
  unifi-controller:
    container_name: unifi-controller
    image: linuxserver/unifi-controller 
    restart: always
    networks:
      - traefik_proxy
    # Even though we're exposing the admin UI via Traefik, we still need direct
    # exposure for other ports for communication with AP(s).
    ports:
      - 8443:8443/tcp
      - 8080:8080/tcp
      - 3478:3478/udp
      - 10001:10001/udp
      # Only needed for captive portal redirect
      #- "8880:8880/tcp
      #- "8843:8843/tcp
      # Only needed for UniFi mobile speedtest
      #- "6789:6789/tcp
      # Only needed for controller L2 discoverable
      #- "1900:1900/udp
      # Only needed for local-bound database
      #- "27117:27117/tcp
      # ????
      #- "8081:8081
    volumes:
      - ${DOCKER_LOCATION}/unifi-controller:/config
    environment:
      - TZ
      - PUID
      - PGID
    labels:
      - traefik.enable=true
      - traefik.http.routers.unifi-controller.rule=Host(`unifi-controller.${DOMAINNAME}`)
      - traefik.http.routers.unifi-controller.entrypoints=websecure
      - traefik.http.routers.unifi-controller.tls=true
      - traefik.http.routers.unifi-controller.tls.certresolver=letsencrypt
      - traefik.http.services.unifi-controller.loadbalancer.server.port=8443
      - traefik.http.services.unifi-controller.loadbalancer.server.scheme=https


  # Homebridge for Homekit integration
#  homebridge:
#    image: oznu/homebridge
#    container_name: homebridge
#    restart: always
#    volumes:
#      - ${DOCKER_LOCATION}/homebridge:/homebridge
#    #network_mode: host
#    networks:
#      direct:
#        ipv4_address: 192.168.1.209
#    #networks:
#    #  - traefik_proxy
#    #ports:
#    #  - 5353:5353/tcp
#    #  - 51826:51826/tcp
#    environment:
#      - PUID
#      - PGID
#      - TZ
#      - HOMEBRIDGE_CONFIG_UI=1
#      - HOMEBRIDGE_CONFIG_UI_PORT=8180
#    #labels:
#    #  - traefik.enable=true
#    #  - traefik.tags=frontend
#    #  - traefik.frontend.passHostHeader=true
#    #  - traefik.admin.backend=unms
#    #  - traefik.admin.frontend.rule=Host:homebridge.${DOMAINNAME}
#    #  - traefik.admin.port=8080
#    #  - traefik.admin.protocol=http


# Docker network definitions, other than default.
networks:
 
  # Network for containers with exposed services (proxied through Traefik)
  traefik_proxy:
    driver: bridge
    driver_opts:
      # Set interface name on host to something meaningful
      com.docker.network.bridge.name: docker_proxy
  
  # Network for exposing a direct IP to a container.
  # Consider for containers that require host networking, or lots of exposed ports,
  # to prevent port overlap.
  direct:
    #external: true  # network not created by docker-compose
    driver: macvlan
    driver_opts:
      parent: enp0s31f6
    ipam:
      config:
        - subnet: 192.168.1.208/28
          # Doesn't work in docker-compose 3.x
          #gateway: 192.168.1.1
          #ip_range: 192.168.1.208/28

  # Default docker bridge network
  default:
    driver: bridge
    driver_opts:
      # Set interface name on host to something meaningful
      com.docker.network.bridge.name: docker_default
